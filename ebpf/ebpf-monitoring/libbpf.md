---
title: Everything about libbpf
---

It does all the heavy lifting of loading the eBPF bytecode directly into the
kernel on the correct hooks.

## `BPF` App Lifecycle and `libbpf` APIs

There are three major things in an BPF application.

- BPF programs
- BPF Maps
- Global variables

> [!IMPORTANT]
> Global variables are shared between BPF programs, which allows them
> to share context and work on common set of data.

### BPF lifecycle

- **Open Phase**: BPF object file is parsed, BPF maps and global variables are
discovered.
- **Load Phase**: BPF maps are created, resolves various relocations and BPF
programs are verified and loaded into the kernel.
- **Attachment Phase**: BPF programs that have been previous loaded into the
kernel are now attached to the BPF hooks (tracepoints, kprobes, cgroups etc.).
Now the BPF programs are actually running and performing their work.
- **Tear Down Phase**: Resources used by BPF are freed up by destroying the
BPF maps and detaching + unloading the BPF programs from the kernel.

## Skeleton Files

Imagine `skeleton` files to be an extra added layer of abstraction that makes
the process of handling the life-cycle of an `BPF` program easier since it
provides helper functions like:

- `<name>__open()`: creates and opens BPF applications.
- `<name>__load()`: instantiates, loads and verifies BPF application parts
- `<name>__attach()`: attaches the auto-attachable BPF programs.
- `<name>__destroy()`: detaches the BPF program and frees up all the space.

There are many more features in built when using skeleton files, but they are
not relevant for us as of now. You can check them out in the official [documentation](https://libbpf.readthedocs.io/en/latest/libbpf_overview.html).

## Entire Process

## Understanding the Makefile for BPF Applications

This document aims to provide a comprehensive breakdown of the provided
`Makefile`, explaining its execution flow, the roles of different files,
and the interaction between user-space and kernel-space components in BPF
(Berkeley Packet Filter) applications.

## 1. Defining Important Files (Overview)

- **Source Code:**
  - `*.bpf.c`: Files containing BPF programs that run in the Linux kernel
  for tracing, monitoring, and networking.
  - `*.c`: User-space application files that interact with BPF programs.
  - `*.h`: Header files shared between BPF and user-space code.
- **Libraries:**
  - `../../libbpf/src`: Source code for `libbpf`, used for loading and managing
  BPF programs.
  - `../../blazesym/`: Source code for `libblazesym`, used for symbolization (if
  `cargo` is available).
- **Tools:**
  - `../../bpftool/src`: Source code for `bpftool`, a utility for managing BPF objects.
- **Generated Files:**
  - `.output/`: Directory for intermediate and final build products.
  - `.output/*.bpf.o`: Compiled BPF bytecode object files.
  - `.output/*.skel.h`: BPF skeleton header files generated by `bpftool`.
  - `.output/*.o`: User-space application object files.
  - `.output/libbpf.a`: Static library for `libbpf`.
  - `.output/libblazesym_c.a`: Static library for `libblazesym`.
  - `bpftool` (in `.output/bpftool/bootstrap/`): Compiled `bpftool` executable.
  - `minimal`, `uprobe`, etc.: Final user-space executable programs.

## 2. Overview of What Each File Does

- **`*.bpf.c`:** Defines BPF program logic for kernel execution.
- **`*.c`:** Provides user-space interface and logic for BPF interaction.
- **`*.h`:** Contains shared definitions for kernel and user-space code.
- **`../../libbpf/src`:** Implements core functionality for BPF program management.
- **`../../blazesym/`:** Enables symbolization for the `profile` application.
- **`../../bpftool/src`:** Offers tools for BPF object management.
- `.output/`: Centralizes generated build artifacts.
- `.output/*.bpf.o`: Stores compiled BPF instructions for kernel loading.
- `.output/*.skel.h`: Simplifies user-space access to BPF program components.
- `.output/*.o`: Contains compiled machine code for user-space applications.
- `.output/libbpf.a`:** Provides compiled `libbpf` code for linking.
- `.output/libblazesym_c.a`:** Provides compiled `libblazesym` code.
- `bpftool`: Command-line tool for BPF object inspection and management.
- `minimal`, `uprobe`, etc.: Runnable programs utilizing BPF.

## 3. How and When Files Are Compiled

The `Makefile` manages compilation based on dependencies and timestamps:

- **`libbpf` Compilation:**
  - Triggered by dependencies on `$(LIBBPF_OBJ)` (`.output/libbpf.a`).
  - Uses `$(MAKE) -C $(LIBBPF_SRC) ... install` to build `libbpf` as a static library.
- **`bpftool` Compilation:**
  - Triggered by dependencies on `$(BPFTOOL)`.
  - Uses `$(MAKE) ARCH= ... -C $(BPFTOOL_SRC) bootstrap` to build `bpftool`.
- **`libblazesym` Compilation (Conditional):**
  - Triggered if `CARGO` is set and a target depends on `$(LIBBLAZESYM_OBJ)`.
  - Uses `cd $(LIBBLAZESYM_SRC) && $(CARGO) build ...` to build `libblazesym`.
- **BPF Program Compilation (`*.bpf.c` to `.output/*.bpf.o`):**
  - Triggered by dependencies on `.bpf.o` files.
  - Uses `$(CLANG) -target bpf ... -c ... -o ...` to compile `*.bpf.c` to `.bpf.o`.
  - Uses `$(BPFTOOL) gen object ...` to finalize the `.bpf.o` file.
- **BPF Skeleton Header Generation (`.output/*.bpf.o` to `.output/*.skel.h`):**
  - Triggered by dependencies on `.skel.h` files.
  - Uses `$(BPFTOOL) gen skeleton ...` to generate `.skel.h` from `.bpf.o`.
- **User-Space Program Compilation (`*.c` to `.output/*.o`):**
  - Triggered by dependencies on `.o` files.
  - Uses `$(CC) $(CFLAGS) $(INCLUDES) -c ... -o ...` to compile `*.c` to `.o`.
- **Application Linking (`.output/*.o` and `libbpf.a` to `minimal`, `uprobe`, etc.):**
  - Triggered by `all` target or application targets.
  - Uses `$(CC) $(CFLAGS) $^ $(ALL_LDFLAGS) -lelf -lz -o $@` to link object
  files and `libbpf`.

## 4. How Many Object Files?

- One user-space `.o` file per application in `APPS`.
- Potentially one BPF `.bpf.o` file per application.
- One `libbpf.a` static library.
- One `libblazesym_c.a` static library (if built).

## 5. Which Object Files Go into the Kernel? Who Sends Them and How?

- BPF object files (`.output/*.bpf.o`) go into the kernel.
- User-space applications load these files using `libbpf` functions.
- `libbpf` sends system calls to load BPF bytecode into the kernel's BPF
virtual machine.
- `bpftool` can also load BPF object files.

## 6. How Does a User-Space Object File Interact with the File Sent to Kernel Space?

- **BPF Maps:** Shared memory regions for data exchange.
- **BPF Probes:** Trigger kernel events for BPF program execution.
- **BPF Links:** Manage connections between BPF programs and kernel events.
- **Control Commands:** User-space applications send commands to BPF programs.
- **BPF Filters:** Network packet filtering or modification.
- `libbpf` and `.skel.h` files facilitate this interaction.

This `Makefile` efficiently manages the build process for BPF applications, ensuring
that only necessary components are rebuilt based on dependencies and timestamps.
